<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../at-core-theme/at-core-theme.html" />
<link rel="import" href="../layout/layout.html" />
<link rel="import" href="../at-carbon-icon/at-carbon-icon.html" />

<!--
A better `<input type="file">`.

### What's wrong with `<input type="file">`?

1. It's difficult to skin/style as the look and feel of the element is mostly determined by the user agent.
2. Access to the selected files are provided via `FileList` object, which is a pseudo-array (not a "real" array, with useful sugar like `forEach`, etc).
3. You want any sort of file validation?  Do it yourself!
4. The API is lacking in many respects.

Now, a new, better, evolved (and evolving) element to take its place: `<at-form-file>`!

@element at-form-file
-->

<dom-module id="at-form-file">
  <style>
    :host {
      position: relative;
    }

    #atFormFileWrapper > .ui.form > .labelContainer > .labelContent {
      font-weight: bold;
    }

    #fileDiv > .ui.action.input > .selectFileButton {
    }

    #fileDiv > .ui.action.input > .selectFileButton > .selectFileButtonIcon {
      display: inline-block;
      vertical-align: middle;
    }

    .buttonText {
      vertical-align: middle;
      white-space: normal;
      padding-left: 6px;
      padding-right: 6px;
      width: 100px;
      margin-right: 30px;
    }

    .hidden {
      display: none;
    }

  </style>
  <template>
    <at-core-theme></at-core-theme>
    <!-- *ij* This html structure is here in place to show what css styles need to be corrected in at-core-theme -->
    <!-- when *ma* makes necessary changes, in place style overrides will be removed -->

    <!-- *ij* This is a case when "ui form" classes are not used -->
    <!-- this results in a input that doesn't fill the width of the container -->
    <!--
    <div id="fileDiv" class="field">
      <div>
        <label>{{label}}</label>
      </div>
      <div class="ui action input" style="display: inline-flex;">
        <input id="fileName" type="text" readonly>
        <div id="buttonDiv" class="ui labeled icon button" on-click="selectFileClickHandler">
          <at-carbon-icon id="aciIcon" class="icon" icon="{{icon}}"></at-carbon-icon>
          <div class="buttonText">Select a file</div>
        </div>
      </div>
    </div>
-->
    <!-- *ij* This is a case when "ui form" classes are used -->
    <!-- this results in a input that does fill the width of the container -->
    <div id="atFormFileWrapper">
      <div class="ui form">
        <div class="labelContainer" id="labelContainer">
          <label class="labelContent">{{label}}</label>
        </div>
        <div id="fileDiv" class="field">
          <div class="ui action input" style="display: inline-flex">
            <input id="fileName" type="text" readonly />
            <button type="button" id="buttonDiv" class="selectFileButton ui button" on-click="selectFileClickHandler">
              <at-carbon-icon id="aciIcon" class="selectFileButtonIcon icon" icon="{{icon}}"></at-carbon-icon>
              Select a file
            </button>
          </div>
        </div>
      </div>
      <input style="visibility: hidden" accept$="{{accept}}" id="fileInputInput" on-change="changeHandler" type="file" />
    </div>
  </template>
</dom-module>
<script>
  'use strict';
  Polymer({
    is: 'at-form-file',
    properties: {
      /**
       * Label for the element
       * @property label
       * @type String
       */
      label: {
        type: String,
        value: ''
      },
      /**
       * Hides the label
       * @property hideLabel
       * @type String
       */
      hideLabel: {
        type: Boolean,
        value: false,
        observer: 'hideLabelChanged'
      },
      /**
       * Name of the icon
       * @property icon
       * @type String
       * @default 'picture'
       */
      icon: {
        type: String,
        value: 'picture'
      },
      /**
       * If you want to restrict the types of files that the file chooser
       * will allow your user's to select, you can make use of an `accept`
       * property, passing one or more MIME types as comma-separated values.
       * Please note that [browser support for this property is poor and implementations vary](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/Input#Browser_compatibility).
       *
       * @property accept
       * @type string
       * @default ''
       */
      accept: {
        type: String,
        value: ''
      },
      /**
       * Some browsers (currently only Chrome and Opera) allow you to
       * select folders for upload.  To turn on this feature (ignored
       * if not supported by the UA), just include this property
       * on the element.
       *
       *     <file-input directory>
       *         Select Files
       *     </file-input>
       *
       * Note: Using this feature may not be a great idea for
       * large directories (or high-latency file systems) since the UI thread
       * is blocked while the file tree is parsed.  This is an unfortunate
       * native implementation detail in the browser.
       *
       *
       * @property directory
       * @type String
       * @default ''
       */
      directory: {
        type: String,
        value: ''
      },
      /**
       * This is a validation property that allows you to filter out any
       * files that do not contain a specific extension.  The value of this
       * property is a JSON array string, containing all extensions to keep.
       * You can also negate your extension array by including a `!` sign
       * just before the array's opening bracket.
       *
       * @property extensions
       * @type String
       * @default ''
       */
      extensions: {
        type: String,
        value: ''
      },
      /**
       * If you'd like to limit the number of files to accept from your
       * users, specify this as an integer value for the `maxFiles` property.
       *
       * For example, to only accept 3 files:
       *
       *     <file-input maxFiles="3">
       *         Select Files
       *     </file-input>
       *
       * If you'd like to completely prevent users from selecting more
       * than one file from the file chooser, you can simply set
       * `maxFiles` to 1:
       *
       *     <file-input maxFiles="1">
       *         Select Files
       *     </file-input>
       *
       * @property maxFiles
       * @type integer
       * @default 0
       */
      maxFiles: {
        type: Number,
        value: 0
      },
      /**
       * Maximum acceptable file size for the purposes of validation.
       * The value is expected to be in bytes.
       *
       * @property maxSize
       * @type Number
       * @default 0
       */
      maxSize: {
        type: Number,
        value: 0
      },
      /**
       * Minimum acceptable file size for the purposes of validation.
       * The value is expected to be in bytes.
       *
       * @property minSize
       * @type Number
       * @default 0
       */
      minSize: {
        type: Number,
        value: 0
      },
      /**
       * Value of the element contains array of valid files and a count of invalid files
       *
       * @property value
       * @type Object
       * @default { invalid: {count: 0}, valid: [] }
       */
      value: {
        type: Object,
        value: {
          invalid: {
            count: 0
          },
          valid: []
        },
        notify: true,
        readOnly: true
      },
      /**
       * Valid state of the element; true = valid, false = invalid
       * @property valid
       * @type Boolean
       * @default true
       */
      valid: {
        type: Boolean,
        value: true,
        readOnly: true
      },
      /**
       * Required state of the element; true = required, false = optional
       * @property required
       * @type Boolean
       * @default false
       */
      required: {
        type: Boolean,
        value: false
      },
      /**
       * Disabled state of the element; true = disabled, false = enabled
       * @property disabled
       * @type Boolean
       * @default false
       */
      disabled: {
        type: Boolean,
        value: false,
        observer: 'disabledChanged'
      },
      /**
       * Hides the element. When hidden nothing is displayed for the element
       * @property hide
       * @type Boolean
       * @default false
       */
      hide: {
        type: Boolean,
        value: false,
        observer: 'hideChanged'
      }
    },
    $meta: [{
      title: "File",
      type: "string",
      xtype: "file"
    }],
    _scopeCssViaAttr: true,
    _isReady: false,
    hideChanged: function (newValue, oldValue) {
      var wrapper = this.$.atFormFileWrapper;
      this.toggleClass('hidden', newValue, wrapper);
    },
    selectFileClickHandler: function() {
      var clickEvent = document.createEvent('MouseEvent');
      clickEvent.initEvent('click', false, true);
      this.$.fileInputInput.dispatchEvent(clickEvent);
    },
    hideLabelChanged: function(newValue, oldValue) {
      this.toggleClass("hidden", newValue, this.$.labelContainer);
    },
    changeHandler: function() {
      var files = Array.prototype.slice.call(this.$.fileInputInput.files),
        invalid = {
          count: 0
        },
        valid = [];

      var sizeValidationResult = this._getResultOfSizeValidation(this.minSize, this.maxSize, files);
      var extensionValidationResult = this._getResultOfExtensionsValidation(this.extensions, sizeValidationResult.valid);
      var countLimitValidationResult = this._getResultOfCountLimitValidation(this.maxFiles, extensionValidationResult.valid);

      if (sizeValidationResult.tooBig.length) {
        invalid.tooBig = sizeValidationResult.tooBig;
        invalid.count += sizeValidationResult.tooBig.length;
      }
      if (sizeValidationResult.tooSmall.length) {
        invalid.tooSmall = sizeValidationResult.tooSmall;
        invalid.count += sizeValidationResult.tooSmall.length;
      }
      if (extensionValidationResult.invalid.length) {
        invalid.badExtension = extensionValidationResult.invalid;
        invalid.count += extensionValidationResult.invalid.length;
      }
      if (countLimitValidationResult.invalid.length) {
        invalid.tooMany = countLimitValidationResult.invalid;
        invalid.count += countLimitValidationResult.invalid.length;
      }

      valid = countLimitValidationResult.valid;

      var newValue = {
        invalid: invalid,
        valid: valid
      };
      this._setValue(newValue);

      if (this.value.valid.length > 0) {
        var selectedFile = this.value.valid[0];
        this.$.fileName.value = selectedFile.name;
      } else {
        this.$.fileName.value = '';
      }

      this.validate();
    },

    created: function() {},

    ready: function() {
      if (this.maxFiles > 1) {
        this.$.fileInputInput.setAttribute("multiple", "");
      }

      if (this.directory && this.$.fileInputInput.webkitdirectory !== undefined) {
        this.$.fileInputInput.setAttribute("webkitdirectory", "");
      }

      var newValue = {
        invalid: {
          count: 0
        },
        valid: []
      };
      this._setValue(newValue);

      this._isReady = true;
    },

    _updateValidState: function() {
      // && this.value ; added this to guard against error that happens when element is validated without first selecting a file
      if (this.required) {
        this._setValid(this.value.valid.length > 0);
      } else {
        this._setValid(true);
      }
    },

    validate: function() {
      this._updateValidState();

      this.toggleClass('error', !this.valid, this.$.fileDiv);

      return this.valid;
    },

    /**
     * To reset the `files` and `invalidFiles` cache on your element,
     * use the `reset()` function:
     *
     *     document.querySelector("file-input").reset();
     *
     * @method reset
     */
    reset: function() {
      this.created();
    },

    _getLowerCaseExtension: function(filename) {
      var extIdx = filename.lastIndexOf(".") + 1;

      if (extIdx > 0) {
        return filename.substr(extIdx, filename.length - extIdx).toLowerCase();
      }
    },

    _getResultOfCountLimitValidation: function(limit, files) {
      if (limit > 0 && limit < files.length) {
        return {
          invalid: files.slice(limit, files.length),
          valid: files.slice(0, limit)
        };
      }

      return {
        invalid: [],
        valid: files
      };
    },

    disabledChanged: function(newValue, oldValue) {
      this.toggleClass('disabled', this.disabled, this.$.buttonDiv);
      if (this.disabled) {
        this.toggleClass('error', false, this.$.fileDiv);
      } else {
        this.toggleClass('error', !this.valid, this.$.fileDiv);
      }
    },

    _getResultOfExtensionsValidation: function(extensionsStr, files) {
      if (extensionsStr) {
        var negate = extensionsStr.charAt(0) === "!",
          extensions = JSON.parse(extensionsStr.toLowerCase().substr(negate ? 1 : 0)),
          result = {
            invalid: [],
            valid: []
          };

        var self = this;
        files.forEach(function(file) {
          var extension = self._getLowerCaseExtension(file.name);

          if (extensions.indexOf(extension) >= 0) {
            result[negate ? "invalid" : "valid"].push(file);
          } else {
            result[negate ? "valid" : "invalid"].push(file);
          }
        });

        return result;
      }

      return {
        invalid: [],
        valid: files
      };
    },

    _getResultOfSizeValidation: function(minSize, maxSize, files) {
      if (!minSize && !maxSize) {
        return {
          tooBig: [],
          tooSmall: [],
          valid: files
        };
      }

      var valid = [],
        tooBig = [],
        tooSmall = [];

      files.forEach(function(file) {
        if (minSize && file.size < minSize) {
          tooSmall.push(file);
        } else if (maxSize && file.size > maxSize) {
          tooBig.push(file);
        } else {
          valid.push(file);
        }
      });

      return {
        tooBig: tooBig,
        tooSmall: tooSmall,
        valid: valid
      };
    }
  });
</script>
<script>
  /**
   * When your user selects new files, a "change" event will be triggered
   * on the element.  The `detail` property on the `event` passed to your
   * handler will contain two properties: `valid` and `invalid`.
   * These correspond to the `files` and `invalidFiles` (respectively)
   * properties on the element instance.
   *
   *     fileInputEl.addEventListener("change",
   *         function(event) {
   *             var validFiles = event.detail.valid,
   *                 invalidFiles = event.detail.invalid;
   *
   *             // handle the event
   *         }
   *     );
   *
   * @event change
   */
</script>
